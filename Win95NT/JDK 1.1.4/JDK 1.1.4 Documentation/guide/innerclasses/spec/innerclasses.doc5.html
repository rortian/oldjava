<html>
<head>
<title> </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table width=600><tr>
<td><a href="innerclasses.doc.html">Contents</a> | <a href="innerclasses.doc4.html">Prev</a> | <a href="innerclasses.doc6.html">Next</a> 
</td><td align=right><i>Inner Classes Specification</i></td>
</tr></table>

<hr><br>
 
<a name="11031"></a>
<h1> Do inner classes affect the correct synchronization of Java code?
</h1>
<a name="14480"></a>
An inner class is part of the implementation of its enclosing class (or classes).  
As such, it has access to the <code>private</code> members of any enclosing class.  This 
means that the programmer must be aware of the possibility of concurrent 
access to state stored in <code>private</code> variables, and ensure that non-<code>private</code> 
methods are correctly synchronized.  Sometimes this just means that the 
enclosing method needs to be declared with the <code>synchronized</code> keyword.
<p><a name="16631"></a>
When more than one object is involved, as with <code>FixedStack</code> and its 
enumerator, the programmer must choose which instance to synchronize upon, 
and write an explicit <code>synchronized</code> statement for the enclosing instance: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="14483"></a>        public Object nextElement() {
    <a name="14484"></a>            ...
    <a name="14485"></a>            synchronized (FixedStack.this) {
    <a name="14486"></a>                return array[--count];
    <a name="14487"></a>            }
    <a name="14488"></a>        }
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
-->
<p><a name="14478"></a>
There is no special relation between the <code>synchronized</code> methods of an inner 
class and the enclosing instance.  To synchronize on an enclosing instance, use 
an explicit <code>synchronized</code> statement.
<p><a name="16662"></a>
When writing multi-threaded code, programmers must always be aware of 
potential asynchronous accesses to shared state variables.  Anonymous inner 
classes make it extremely easy to create threads which share private fields or 
local variables.  The programmer must take care either to synchronize access to 
these variables, or to make separate copies of them for each thread.  For 
example, this <code>for</code>-loop needs to make copies of its index variable: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>    <a name="16681"></a>    for (int ii = 0; ii &lt; getBinCount(); ii++) {
    <a name="16711"></a>        final int i = ii; // capture a stable copy for each thread
    <a name="16712"></a>        Runnable r = new Runnable() {
    <a name="16713"></a>            public void run() { processBin(i); }
    <a name="16684"></a>        };
    <a name="16685"></a>        new Thread(r, "processBin("+i+")").start();
    <a name="16682"></a>    }
</pre>

</Table>

<!--
<Table>
<tr><td>
</Table>
-->
<p><a name="19968"></a>
It is a common mistake to try to use the loop index directly within the inner 
class body.  Since the index is not <code>final</code>, the compiler reports an error.
<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="innerclasses.doc.html">Contents</a> | <a href="innerclasses.doc4.html">Prev</a> | <a href="innerclasses.doc6.html">Next</a> 

<p>
<font size=-1>Inner Classes Specification (HTML generated by dkramer on March 15, 1997)<br>
<i><a href="copyright.doc.html">Copyright &#169 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:john.rose@eng.sun.com">john.rose@eng.sun.com</a>
</font>
</body></html>